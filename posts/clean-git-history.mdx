---
title: Clean Git History Using Rebase
description: How to keep your git history clean with rebase
published: '2021-6-7'
category: 'Git'
image: '/images/clean-git-history/og-image.webp'
---

# Clean Git History Using Rebase

Recently I wrote about [how you should rethink your git commits](https://joyofcode.xyz/rethink-how-you-write-git-commits) where I explain the benefits of having a readable Git history.

I want to go a step further and show you how to have complete control over your Git history â€” rewrite it, keep a linear project history, and integrate upstream changes.

## What You're Going to Learn

- How to use `git rebase`
- Have complete control of your Git history
- How to keep your branch up to date with upstream
- Difference between `git merge`, and `git rebase`

## Before You Get Started

I find most explanations confusing because they spend time explaining features instead of showing you how to use the feature.

Visual learning is key to understanding and using these concepts. That's why if possible, I encourage you to follow along. Open a project, and initialize a Git repository:

```shell:terminal
# initialize new project
git init

# add everything
git add .

# add commit
git commit -m "Start of project"

# rename "master" to "main"
git branch -m master main
```

Set your code editor as the default Git editor:

```shell:terminal
# check if you have your editor set up
git config --get core.editor

# sets default editor to VS Code
git config --global core.editor "code --wait"
```

Learn more from the [VS Code as Git Editor](https://code.visualstudio.com/docs/editor/versioncontrol#_vs-code-as-git-editor) documentation. If you are using another editor you can see [a list of configuration commands](https://git-scm.com/book/en/v2/Appendix-C%3A-Git-Commands-Setup-and-Config).

We are using the [Git Graph](https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph) VS Code extension to get a visual representation of our Git history.

## What is Git Rebase?

Git rebase specializes in integrating changes from one branch to another:

- Rebase can **rewrite history** and **alter individual commits**
- **Integrate changes back into your feature branch** so you're up to date
- **Integrate feature branch changes** into the main branch
- It's **easier reasoning** about Git history

## Using Git Rebase to Rewrite History

This is going to be a contrived example for sake of learning. We're not going to write actual code.

We're asked to add a feature to display a list of Pokemon. The steps we're going to take are:

- Create a `feature/pokemon` branch
- Add a `pokemon.js` and `styles.css` file

Create a feature branch:

```shell:terminal
git checkout -b feature/pokemon
```

You terminal, and editor should indicate you're on the right branch:

<Image
  height={1052}
  width={960}
  src="/images/clean-git-history/vs-code.png"
  alt="VS Code Editor"
/>

Add the `pokemon.js` file:

```js:pokemon.js
// Fetch, and display Pokemon
```

Stage the file, and commit it:

```shell:terminal
git add pokemon.js

git commit -m "feat: Fetch, and display Pokemon"
```

Do the same for `styles.css` (write anything you want inside of it):

```css:styles.css
/* Pokemon styles */
```

```shell:terminal
git add styles.css

git commit -m "style: Add Pokemon styles"
```

<Image
  height={185}
  width={957}
  src="/images/clean-git-history/first-commits.png"
  alt="Shows first couple of commits"
/>

At this stage we could do `git checkout main` and `git merge feature/pokemon` to merge the changes.

This would create an extra meaningless merge commit for us if we worked on a file from the main branch, or if the main branch was ahead in our history.

Let's look at our Git log:

```shell:terminal
git log --oneline

# fd9eb31 (HEAD -> feature/pokemon) style: Add Pokemon styles
# 3e2fc0a feat: Fetch, and display Pokemon
#3c03f44 Start of project
```

After the changes:

```shell:terminal
git log --oneline

# fd9eb31 (HEAD -> main, feature/pokemon) style: Add Pokemon styles
# 3e2fc0a feat: Fetch, and display Pokemon
#3c03f44 Start of project
```

If you're playing around and make a mistake you can always do `git reset --hard fd9eb317` which would bring you back to the "style: Add Pokemon styles" commit in Git history.

After we're done merging the changes we would remove the branch with `git branch -d feature/pokemon` since we no longer need it (you will have to repeat the previous steps if you do it).

<Image
  height={178}
  width={958}
  src="/images/clean-git-history/first-merge.png"
  alt="Shows first couple of commits"
/>

Instead of using merge, let us use **interactive rebase**. This gives us the ability to **alter**, and even **reorder** our commits if we wanted to:

- **We don't have to include a bunch of random commits** into our Git history for a feature
- Instead we can **squash** them into a single commit

Let's take a look at our log, so we understand what we want to accomplish:

```shell:terminal
git log --oneline

# c36072d (HEAD -> main) Add Pokemon styles
# a3a28ed Fetch, and display Pokemon
# 3c03f44 Start of project
```

Wouldn't it be nicer if we could have only one feature commit that adds Pokemon? This is possible with rebase.

```shell:terminal
# c36072d (HEAD -> main) Add Pokemon
# 3c03f44 Start of project
```

Let's go back to our branch `git checkout feature/pokemon` and start rebase:

```shell:terminal
git rebase -i HEAD~2
```

The `-i` command-line parameter means "run rebase in interactive mode". The `HEAD~2` specifies the last two commits from our Git history:

<Image
  height={1052}
  width={960}
  src="/images/clean-git-history/rebase-open.png"
  alt="Shows rebase window"
/>

You can ignore most of the output unless you want to read. The only thing that's important is our commits at the top.

**The most useful to us is the ability to edit a commit message, reorder the commits, and squash commits into a single commit.**

Let's take a look at the top of the file:

```shell:terminal
# pick 0970ca5 feat: Fetch, and display Pokemon
# pick 6b144c0 style: Add Pokemon styles
```

**When squashing you leave the top commit alone.** For others we change "pick" to "squash", or use the abbreviation "s":

```shell:terminal
# pick 0970ca5 feat: Fetch, and display Pokemon
# squash 6b144c0 style: Add Pokemon styles
```

After you're done save the file and close it. Another file is going to open. This is where we change our commit message.

<Image
  height={1052}
  width={960}
  src="/images/clean-git-history/rebase-commit.png"
  alt="Shows rebase commit message window"
/>

We can delete most of it and enter our commit message. Close it after you're done.

<Image
  height={1052}
  width={960}
  src="/images/clean-git-history/rebase-commit-change.png"
  alt="Shows rebase commit change"
/>

We can also stop the rebase at any point with `git rebase --abort`. If we have conflicts, after resolving them we can use `git rebase --continue`.

We're still on the `feature/pokemon` branch, so let's `git checkout main` to the main branch.

<Image
  height={144}
  width={957}
  src="/images/clean-git-history/rebase-checkout.png"
  alt="Shows checkout to main branch after rebase"
/>

The only thing left to do is rebase the changes:

```shell:terminal
git rebase feature/pokemon
```

<Image
  height={138}
  width={956}
  src="/images/clean-git-history/rebase-complete.png"
  alt="Shows completed rebase on main branch"
/>

That's it. Just as before we can delete our branch if we want. Note that if you're working with a remote branch you have to force push the changes with `git push -f <remote> <branch>` which is fine.

## When Not to Use Rebase

- **Never use rebase on a public branch** (you shouldn't rewrite the history for others and cause problems by force pushing)
- **Only use rebase if you're the only person working on a branch** (this is why it's acceptable to force push your changes to a remote branch)
- **Try to keep things local** so you can do whatever you want

## Using Rebase to Keep Your Branch Up To Date

Let's say we're working on our Pokemon feature. Our crack team of backend developers are working hard on implementing the API. Since it's not ready we had to use a mock API during the development of the feature. At one point our **feature branch** is going to get behind our main branch:

<Image
  height={217}
  width={955}
  src="/images/clean-git-history/feature-behind-upstream.png"
  alt="Shows feature branch is behind upstream"
/>

```shell:terminal
git log --oneline

# 7b9cdee (HEAD -> feature/pokemon) style: Add Pokemon styles
# 691dbc5 feat: Fetch, and display Pokemon
# 3c03f44 Start of project
```

How do we base our changes on the latest commit? We could always merge the changes using `git pull` which is shorthand for `git fetch` followed by `git merge origin main`. This would leave a merge commit that's not useful to our history. We can use `git rebase` instead.

Assuming we're on the `feature/pokemon` branch:

```shell:terminal
git rebase main
```

<Image
  height={261}
  width={956}
  src="/images/clean-git-history/feature-behind-rebase.png"
  alt="Shows feature branch up to date with upstream"
/>

```shell:terminal
git log --oneline

# 47c17c4 (HEAD -> feature/pokemon) style: Add Pokemon styles
# df60798 feat: Fetch, and display Pokemon
# 95a14c5 (main) feat: Add Pokemon API
# 3c03f44 Start of project
```

From here we can do an interactive rebase and make further changes. After we're done we `git checkout main` and `git rebase feature/pokemon` followed by removing `git branch -d feature/pokemon`.

## Closing Thoughts

You can always go back in time if you make a mistake. That includes altering the Git history. It might appear your old commits are gone, but they're not. You can restore and even undo rebase with [git reflog](https://www.atlassian.com/git/tutorials/rewriting-history/git-reflog).

Thank you for reading and have a nice day!
